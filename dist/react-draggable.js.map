{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a32865a015d560c6fcf4","webpack:///./src/draggable.jsx","webpack:///external \"React\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,gCAAgC;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,yCAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA,SAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,cAAc;AACnD,oDAAmD,WAAW;AAC9D;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAE;;AAEF;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA,sBAAqB;AACrB;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;;;;;;AC5pBD,gD","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"React\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"React\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactDraggable\"] = factory(require(\"React\"));\n\telse\n\t\troot[\"ReactDraggable\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap a32865a015d560c6fcf4\n **/","'use strict';\n\nvar React = require('react/addons');\nvar emptyFunction = function () {};\n\n// for accessing browser globals\nvar root = typeof window !== 'undefined' ? window : this;\nvar bodyElement;\nif (typeof document !== 'undefined' && 'body' in document) {\n\tbodyElement = document.body;\n}\n\nfunction updateBoundState (state, bound) {\n\tif (!bound) return state;\n\tbound = String(bound);\n\tvar boundTop = !!~bound.indexOf('top');\n\tvar boundRight = !!~bound.indexOf('right');\n\tvar boundBottom = !!~bound.indexOf('bottom');\n\tvar boundLeft = !!~bound.indexOf('left');\n\tvar boundAll = !!~bound.indexOf('all') ||\n\t\t!(boundTop || boundRight || boundBottom || boundLeft);\n\tvar boundBox = !~bound.indexOf('point');\n\tstate.boundTop = boundAll || boundTop;\n\tstate.boundRight = boundAll || boundRight;\n\tstate.boundBottom = boundAll || boundBottom;\n\tstate.boundLeft = boundAll || boundLeft;\n\tstate.boundBox = boundBox;\n\treturn state;\n};\n\nfunction createUIEvent(draggable) {\n\treturn {\n\t\tposition: {\n\t\t\ttop: draggable.state.offsetTop,\n\t\t\tleft: draggable.state.offsetLeft\n\t\t}\n\t};\n}\n\nfunction canDragY(draggable) {\n\treturn draggable.props.axis === 'both' ||\n\t\t\tdraggable.props.axis === 'y';\n}\n\nfunction canDragX(draggable) {\n\treturn draggable.props.axis === 'both' ||\n\t\t\tdraggable.props.axis === 'x';\n}\n\nfunction isFunction(func) {\n\treturn typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]'\n}\n\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array, callback) {\n\tfor (var i = 0, length = array.length, element = null; i < length, element = array[i]; i++) {\n\t\tif (callback.apply(callback, [element, i, array])) return element;\n\t}\n}\n\nfunction matchesSelector(el, selector) {\n\tvar method = findInArray([\n\t\t'matches',\n\t\t'webkitMatchesSelector',\n\t\t'mozMatchesSelector',\n\t\t'msMatchesSelector',\n\t\t'oMatchesSelector'\n\t], function(method){\n\t\treturn isFunction(el[method]);\n\t});\n\n\treturn el[method].call(el, selector);\n}\n\n// @credits: http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript/4819886#4819886\nvar isTouchDevice = 'ontouchstart' in root // works on most browsers\n\t\t\t\t\t\t\t\t || 'onmsgesturechange' in root; // works on ie10 on ms surface\n\n// look ::handleDragStart\n//function isMultiTouch(e) {\n//  return e.touches && Array.isArray(e.touches) && e.touches.length > 1\n//}\n\n/**\n * simple abstraction for dragging events names\n * */\nvar dragEventFor = (function () {\n\tvar eventsFor = {\n\t\ttouch: {\n\t\t\tstart: 'touchstart',\n\t\t\tmove: 'touchmove',\n\t\t\tend: 'touchend'\n\t\t},\n\t\tmouse: {\n\t\t\tstart: 'mousedown',\n\t\t\tmove: 'mousemove',\n\t\t\tend: 'mouseup'\n\t\t}\n\t};\n\treturn eventsFor[isTouchDevice ? 'touch' : 'mouse'];\n})();\n\n/**\n * get {clientX, clientY} positions of control\n * */\nfunction getControlPosition(e) {\n\tvar position = (e.touches && e.touches[0]) || e;\n\treturn {\n\t\tclientX: position.clientX,\n\t\tclientY: position.clientY\n\t}\n}\n\nfunction addEvent(el, event, handler) {\n\tif (!el) { return; }\n\tif (el.attachEvent) {\n\t\tel.attachEvent('on' + event, handler);\n\t} else if (el.addEventListener) {\n\t\tel.addEventListener(event, handler, true);\n\t} else {\n\t\tel['on' + event] = handler;\n\t}\n}\n\nfunction removeEvent(el, event, handler) {\n\tif (!el) { return; }\n\tif (el.detachEvent) {\n\t\tel.detachEvent('on' + event, handler);\n\t} else if (el.removeEventListener) {\n\t\tel.removeEventListener(event, handler, true);\n\t} else {\n\t\tel['on' + event] = null;\n\t}\n}\n\nmodule.exports = React.createClass({\n\tdisplayName: 'Draggable',\n\tmixins: [React.addons.PureRenderMixin],\n\n\tpropTypes: {\n\t\t/**\n\t\t * `axis` determines which axis the draggable can move.\n\t\t *\n\t\t * 'both' allows movement horizontally and vertically.\n\t\t * 'x' limits movement to horizontal axis.\n\t\t * 'y' limits movement to vertical axis.\n\t\t *\n\t\t * Defaults to 'both'.\n\t\t */\n\t\taxis: React.PropTypes.oneOf(['both', 'x', 'y']),\n\n\t\t/**\n\t\t * `handle` specifies a selector to be used as the handle that initiates drag.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t * \tvar App = React.createClass({\n\t\t * \t    render: function () {\n\t\t * \t    \treturn (\n\t\t * \t    \t \t<Draggable handle=\".handle\">\n\t\t * \t    \t \t  <div>\n\t\t * \t    \t \t      <div className=\"handle\">Click me to drag</div>\n\t\t * \t    \t \t      <div>This is some other content</div>\n\t\t * \t    \t \t  </div>\n\t\t * \t    \t\t</Draggable>\n\t\t * \t    \t);\n\t\t * \t    }\n\t\t * \t});\n\t\t * ```\n\t\t */\n\t\thandle: React.PropTypes.string,\n\n\t\t/**\n\t\t * `cancel` specifies a selector to be used to prevent drag initialization.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t * \tvar App = React.createClass({\n\t\t * \t    render: function () {\n\t\t * \t        return(\n\t\t * \t            <Draggable cancel=\".cancel\">\n\t\t * \t                <div>\n\t\t * \t                \t<div className=\"cancel\">You can't drag from here</div>\n\t\t *\t\t\t\t\t\t<div>Dragging here works fine</div>\n\t\t * \t                </div>\n\t\t * \t            </Draggable>\n\t\t * \t        );\n\t\t * \t    }\n\t\t * \t});\n\t\t * ```\n\t\t */\n\t\tcancel: React.PropTypes.string,\n\n\t\t/**\n\t\t * `bound` determines whether to bound the movement to the parent box.\n\t\t *\n\t\t * The property takes a list of space-separated strings. The Draggable\n\t\t * is bounded by the nearest DOMNode.offsetParent. To set the offset\n\t\t * parent, give it a position value other than 'static'.\n\t\t *\n\t\t * Optionally choose one or more bounds from:\n\t\t * 'top' bounds movement to the top edge of the parent box.\n\t\t * 'right' bounds movement to the right edge of the parent box.\n\t\t * 'bottom' bounds movement to the bottom edge of the parent box.\n\t\t * 'left' bounds movement to the left edge of the parent box.\n\t\t * 'all' bounds movement to all edges (default if not specified).\n\t\t *\n\t\t * Optionally choose one anchor from:\n\t\t * 'point' to constrain only the top-left corner.\n\t\t * 'box' to constrain the entire box (default if not specified).\n\t\t *\n\t\t * You may use more than one bound, e.g. 'top left point'. Set to a\n\t\t * falsy value to disable.\n\t\t *\n\t\t * Defaults to 'all box'.\n\t\t */\n\t\tbound: React.PropTypes.string,\n\n\t\t/**\n\t\t * `grid` specifies the x and y that dragging should snap to.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t *   var App = React.createClass({\n\t\t *       render: function () {\n\t\t *           return (\n\t\t * \t            <Draggable grid={[25, 25]}>\n\t\t *                   <div>I snap to a 25 x 25 grid</div>\n\t\t *               </Draggable>\n\t\t *           );\n\t\t * \t    }\n\t\t *   });\n\t\t * ```\n\t\t */\n\t\tgrid: React.PropTypes.arrayOf(React.PropTypes.number),\n\n\t\t/**\n\t\t * `constrain` takes a function to constrain the dragging.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t *   function constrain (snap) {\n\t\t *         function constrainOffset (offset, prev) {\n\t\t *               var delta = offset - prev;\n\t\t *               if (Math.abs(delta) >= snap) {\n\t\t *                     return prev + (delta < 0 ? -snap : snap);\n\t\t *               }\n\t\t *               return prev;\n\t\t *         }\n\t\t *         return function (pos) {\n\t\t *               return {\n\t\t *                     top: constrainOffset(pos.top, pos.prevTop),\n\t\t *                     left: constrainOffset(pos.left, pos.prevLeft)\n\t\t *               };\n\t\t *         };\n\t\t *   }\n\t\t *   var App = React.createClass({\n\t\t *       render: function () {\n\t\t *           return (\n\t\t *               <Draggable constrain={constrain}>\n\t\t *                   <div>I snap to a 25 x 25 grid</div>\n\t\t *               </Draggable>\n\t\t *           );\n\t\t *       }\n\t\t *   });\n\t\t * ```\n\t\t */\n\t\tconstrain: React.PropTypes.func,\n\n\t\t/**\n\t\t * `start` specifies the x and y that the dragged item should start at\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t * \tvar App = React.createClass({\n\t\t * \t    render: function () {\n\t\t * \t        return (\n\t\t * \t            <Draggable start={{x: 25, y: 25}}>\n\t\t * \t                <div>I start with left: 25px; top: 25px;</div>\n\t\t * \t            </Draggable>\n\t\t * \t        );\n\t\t * \t    }\n\t\t * \t});\n\t\t * ```\n\t\t */\n\t\tstart: React.PropTypes.object,\n\n\t\t/**\n\t\t * `zIndex` specifies the zIndex to use while dragging.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```jsx\n\t\t * \tvar App = React.createClass({\n\t\t * \t    render: function () {\n\t\t * \t        return (\n\t\t * \t            <Draggable zIndex={100}>\n\t\t * \t                <div>I have a zIndex</div>\n\t\t * \t            </Draggable>\n\t\t * \t        );\n\t\t * \t    }\n\t\t * \t});\n\t\t * ```\n\t\t */\n\t\tzIndex: React.PropTypes.number,\n\n\t\t/**\n\t\t * `useChild` determines whether to use the first child as root.\n\t\t *\n\t\t * If false, a div is created. This option is required if any children\n\t\t * have a ref.\n\t\t *\n\t\t * Defaults to true.\n\t\t */\n\t\tuseChild: React.PropTypes.bool,\n\n\t\t/**\n\t\t * Called when dragging starts.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```js\n\t\t *\tfunction (event, ui) {}\n\t\t * ```\n\t\t *\n\t\t * `event` is the Event that was triggered.\n\t\t * `ui` is an object:\n\t\t *\n\t\t * ```js\n\t\t *\t{\n\t\t *\t\tposition: {top: 0, left: 0}\n\t\t *\t}\n\t\t * ```\n\t\t */\n\t\tonStart: React.PropTypes.func,\n\n\t\t/**\n\t\t * Called while dragging.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```js\n\t\t *\tfunction (event, ui) {}\n\t\t * ```\n\t\t *\n\t\t * `event` is the Event that was triggered.\n\t\t * `ui` is an object:\n\t\t *\n\t\t * ```js\n\t\t *\t{\n\t\t *\t\tposition: {top: 0, left: 0}\n\t\t *\t}\n\t\t * ```\n\t\t */\n\t\tonDrag: React.PropTypes.func,\n\n\t\t/**\n\t\t * Called when dragging stops.\n\t\t *\n\t\t * Example:\n\t\t *\n\t\t * ```js\n\t\t *\tfunction (event, ui) {}\n\t\t * ```\n\t\t *\n\t\t * `event` is the Event that was triggered.\n\t\t * `ui` is an object:\n\t\t *\n\t\t * ```js\n\t\t *\t{\n\t\t *\t\tposition: {top: 0, left: 0}\n\t\t *\t}\n\t\t * ```\n\t\t */\n\t\tonStop: React.PropTypes.func,\n\n\t\t/**\n\t\t * A workaround option which can be passed if onMouseDown needs to be accessed, since it'll always be blocked (due to that there's internal use of onMouseDown)\n\t\t *\n\t\t */\n\t\tonMouseDown: React.PropTypes.func\n\t},\n\n\tgetDefaultProps: function () {\n\t\treturn {\n\t\t\taxis: 'both',\n\t\t\tbound: null,\n\t\t\thandle: null,\n\t\t\tcancel: null,\n\t\t\tgrid: null,\n\t\t\tstart: {},\n\t\t\tzIndex: NaN,\n\t\t\tuseChild: true,\n\t\t\tonStart: emptyFunction,\n\t\t\tonDrag: emptyFunction,\n\t\t\tonStop: emptyFunction,\n\t\t\tonMouseDown: emptyFunction\n\t\t};\n\t},\n\n\tgetInitialState: function () {\n\t\tvar state = {\n\t\t\t// Whether or not currently dragging\n\t\t\tdragging: false,\n\n\t\t\t// Pointer offset on screen\n\t\t\tclientX: 0, clientY: 0,\n\n\t\t\t// DOMNode offset relative to parent\n\t\t\toffsetLeft: this.props.start.x || 0, offsetTop: this.props.start.y || 0\n\t\t};\n\n\t\tupdateBoundState(state, this.props.bound);\n\n\t\treturn state;\n\t},\n\n\tcomponentWillReceiveProps: function (nextProps) {\n\t\tvar state = updateBoundState({}, nextProps.bound);\n\t\tif (nextProps.start) {\n\t\t\tif (nextProps.start.x != null) {\n\t\t\t\tstate.offsetLeft = nextProps.start.x || 0;\n\t\t\t}\n\t\t\tif (nextProps.start.y != null) {\n\t\t\t\tstate.offsetTop = nextProps.start.y || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setState(state);\n\t},\n\n\tcomponentWillUnmount: function() {\n\t\t// Remove any leftover event handlers\n\t\tremoveEvent(root, dragEventFor['move'], this.handleDrag);\n\t\tremoveEvent(root, dragEventFor['end'], this.handleDragEnd);\n\t},\n\n\thandleDragStart: function (e) {\n\t\t// todo: write right implementation to prevent multitouch drag\n\t\t// prevent multi-touch events\n\t\t// if (isMultiTouch(e)) {\n\t\t//     this.handleDragEnd.apply(e, arguments);\n\t\t//     return\n\t\t// }\n\n\t\t// Make it possible to attach event handlers on top of this one\n\t\tthis.props.onMouseDown(e);\n\n\t\t// Short circuit if handle or cancel prop was provided and selector doesn't match\n\t\tif ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||\n\t\t\t(this.props.cancel && matchesSelector(e.target, this.props.cancel))) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar dragPoint = getControlPosition(e);\n\n\t\t// Initiate dragging\n\t\tthis.setState({\n\t\t\tdragging: true,\n\t\t\tclientX: dragPoint.clientX,\n\t\t\tclientY: dragPoint.clientY\n\t\t});\n\n\t\t// Call event handler\n\t\tthis.props.onStart(e, createUIEvent(this));\n\n\t\t// Add event handlers\n\t\taddEvent(root, dragEventFor['move'], this.handleDrag);\n\t\taddEvent(root, dragEventFor['end'], this.handleDragEnd);\n\n\t\t// Add dragging class to body element\n\t\tif (bodyElement) bodyElement.className += ' react-draggable-dragging';\n\t},\n\n\thandleDragEnd: function (e) {\n\t\t// Short circuit if not currently dragging\n\t\tif (!this.state.dragging) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Turn off dragging\n\t\tthis.setState({\n\t\t\tdragging: false\n\t\t});\n\n\t\t// Call event handler\n\t\tthis.props.onStop(e, createUIEvent(this));\n\n\t\t// Remove event handlers\n\t\tremoveEvent(root, dragEventFor['move'], this.handleDrag);\n\t\tremoveEvent(root, dragEventFor['end'], this.handleDragEnd);\n\n\t\t// Remove dragging class from body element\n\t\tif (bodyElement) {\n\t\t\tvar className = bodyElement.className;\n\t\t\tbodyElement.className =\n\t\t\t\tclassName.replace(/(?:^|\\s+)react-draggable-dragging\\b/, ' ');\n\t\t}\n\t},\n\n\thandleDrag: function (e) {\n\t\tvar dragPoint = getControlPosition(e);\n\t\tvar offsetLeft = this._toPixels(this.state.offsetLeft);\n\t\tvar offsetTop = this._toPixels(this.state.offsetTop);\n\n\t\tvar state = {\n\t\t\toffsetLeft: offsetLeft,\n\t\t\toffsetTop: offsetTop\n\t\t};\n\n\t\t// Get parent DOM node\n\t\tvar node = this.getDOMNode();\n\t\tvar offsetParent = node.offsetParent;\n\t\tvar offset, boundingValue;\n\n\t\tif (canDragX(this)) {\n\t\t\t// Calculate updated position\n\t\t\toffset = offsetLeft + dragPoint.clientX - this.state.clientX;\n\n\t\t\t// Bound movement to parent box\n\t\t\tif (this.state.boundLeft) {\n\t\t\t\tboundingValue = state.offsetLeft - node.offsetLeft;\n\t\t\t\tif (offset < boundingValue) {\n\t\t\t\t\toffset = boundingValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.state.boundRight) {\n\t\t\t\tboundingValue += offsetParent.clientWidth;\n\t\t\t\tif (this.state.boundBox) {\n\t\t\t\t\tboundingValue -= node.offsetWidth;\n\t\t\t\t}\n\t\t\t\tif (offset > boundingValue) {\n\t\t\t\t\toffset = boundingValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update left\n\t\t\tstate.offsetLeft = offset;\n\t\t}\n\n\t\tif (canDragY(this)) {\n\t\t\t// Calculate updated position\n\t\t\toffset = offsetTop + dragPoint.clientY - this.state.clientY;\n\t\t\t// Bound movement to parent box\n\t\t\tif (this.state.boundTop) {\n\t\t\t\tboundingValue = state.offsetTop - node.offsetTop;\n\t\t\t\tif (offset < boundingValue) {\n\t\t\t\t\toffset = boundingValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.state.boundBottom) {\n\t\t\t\tboundingValue += offsetParent.clientHeight;\n\t\t\t\tif (this.state.boundBox) {\n\t\t\t\t\tboundingValue -= node.offsetHeight;\n\t\t\t\t}\n\t\t\t\tif (offset > boundingValue) {\n\t\t\t\t\toffset = boundingValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update top\n\t\t\tstate.offsetTop = offset;\n\t\t}\n\n\t\tvar constrain = this.props.constrain;\n\t\tvar grid = this.props.grid;\n\n\t\t// Backwards-compatibility for snap to grid\n\t\tif (!constrain && Array.isArray(grid)) {\n\t\t\tvar constrainOffset = function (offset, prev, snap) {\n\t\t\t\tvar delta = offset - prev;\n\t\t\t\tif (Math.abs(delta) >= snap) {\n\t\t\t\t\treturn prev + parseInt(delta / snap, 10) * snap;\n\t\t\t\t}\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tconstrain = function (pos) {\n\t\t\t\treturn {\n\t\t\t\t\tleft: constrainOffset(pos.left, pos.prevLeft, grid[0]),\n\t\t\t\t\ttop: constrainOffset(pos.top, pos.prevTop, grid[1])\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t// Constrain if function has been provided\n\t\tvar positions;\n\t\tif (constrain) {\n\t\t\t// Constrain positions\n\t\t\tpositions = constrain({\n\t\t\t\tprevLeft: this.state.offsetLeft,\n\t\t\t\tprevTop: this.state.offsetTop,\n\t\t\t\tleft: state.offsetLeft,\n\t\t\t\ttop: state.offsetTop\n\t\t\t});\n\t\t\tif (positions) {\n\t\t\t\t// Update left\n\t\t\t\tif ('left' in positions && !isNaN(positions.left)) {\n\t\t\t\t\tstate.offsetLeft = positions.left;\n\t\t\t\t}\n\t\t\t\t// Update top\n\t\t\t\tif ('top' in positions && !isNaN(positions.top)) {\n\t\t\t\t\tstate.offsetTop = positions.top;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Save new state\n\t\tstate.clientX = this.state.clientX + (state.offsetLeft - offsetLeft);\n\t\tstate.clientY = this.state.clientY + (state.offsetTop - offsetTop);\n\t\tthis.setState(state);\n\n\t\t// Call event handler\n\t\tthis.props.onDrag(e, createUIEvent(this));\n\t},\n\n\tonTouchStart: function (e) {\n\t\te.preventDefault(); // prevent for scroll\n\t\treturn this.handleDragStart.apply(this, arguments);\n\t},\n\n\trender: function () {\n\t\tvar style = {\n\t\t\ttop: this.state.offsetTop,\n\t\t\tleft: this.state.offsetLeft\n\t\t};\n\n\t\t// Set zIndex if currently dragging and prop has been provided\n\t\tif (this.state.dragging && !isNaN(this.props.zIndex)) {\n\t\t\tstyle.zIndex = this.props.zIndex;\n\t\t}\n\n \t\tvar props = {\n \t\t\tstyle: style,\n \t\t\tclassName: 'react-draggable',\n\n \t\t\tonMouseDown: this.handleDragStart,\n \t\t\tonTouchStart: this.onTouchStart,\n\n \t\t\tonMouseUp: this.handleDragEnd,\n \t\t\tonTouchEnd: this.handleDragEnd\n \t\t};\n\n\t\t// Reuse the child provided\n\t\t// This makes it flexible to use whatever element is wanted (div, ul, etc)\n\t\tif (this.props.useChild) {\n\t\t\treturn React.addons.cloneWithProps(React.Children.only(this.props.children), props);\n\t\t}\n\n\t\treturn React.DOM.div(props, this.props.children);\n\t},\n\n\t_toPixels: function (value) {\n\n\t\t// Support percentages\n\t\tif (typeof value == 'string' && value.slice(-1) == '%') {\n\t\t\treturn parseInt((+value.replace('%', '') / 100) *\n\t\t\t\tthis.getDOMNode().offsetParent.clientWidth, 10) || 0;\n\t\t}\n\n\t\t// Invalid values become zero\n\t\tvar i = parseInt(value, 10);\n\t\tif (isNaN(i) || !isFinite(i)) return 0;\n\n\t\treturn i;\n\t}\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/draggable.jsx\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"React\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"react-draggable.js"}